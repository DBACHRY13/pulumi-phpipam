// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as utilities from "./utilities";

/**
 * ## # phpipam.Subnet
 *
 * The `phpipam.Subnet` data source gets information on a subnet such as its ID
 * (required for creating addresses), description, and more.
 *
 * **Example:**
 *
 * <!--Start PulumiCodeChooser -->
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as phpipam from "@pulumi/phpipam";
 *
 * const subnet = phpipam.getSubnet({
 *     subnetAddress: "10.10.2.0",
 *     subnetMask: 24,
 * });
 * // Reserve the address.
 * const newip = new phpipam.Address("newip", {
 *     subnetId: subnet.then(subnet => subnet.subnetId),
 *     ipAddress: "10.10.2.10",
 *     hostname: "tf-test-host.example.internal",
 *     description: "Managed by Terraform",
 * });
 * ```
 * <!--End PulumiCodeChooser -->
 *
 * **Example with `descriptionMatch`:**
 *
 * <!--Start PulumiCodeChooser -->
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as phpipam from "@pulumi/phpipam";
 *
 * const subnet = phpipam.getSubnet({
 *     sectionId: 1,
 *     descriptionMatch: "[Cc]ustomer 2",
 * });
 * const nextAddress = subnet.then(subnet => phpipam.getFirstFreeAddress({
 *     subnetId: subnet.subnetId,
 * }));
 * // Reserve the address. Note that we use ignore_changes here to ensure that we
 * // don't end up re-allocating this address on future Terraform runs.
 * const newip = new phpipam.Address("newip", {
 *     subnetId: subnet.then(subnet => subnet.subnetId),
 *     ipAddress: nextAddress.then(nextAddress => nextAddress.ipAddress),
 *     hostname: "tf-test-host.example.internal",
 *     description: "Managed by Terraform",
 * });
 * ```
 * <!--End PulumiCodeChooser -->
 *
 * **Example With `customFieldFilter`:**
 *
 * <!--Start PulumiCodeChooser -->
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as phpipam from "@pulumi/phpipam";
 *
 * const subnet = phpipam.getSubnet({
 *     sectionId: 1,
 *     customFieldFilter: {
 *         custom_CustomTestSubnets: ".*terraform.*",
 *     },
 * });
 * const nextAddress = subnet.then(subnet => phpipam.getFirstFreeAddress({
 *     subnetId: subnet.subnetId,
 * }));
 * // Reserve the address. Note that we use ignore_changes here to ensure that we
 * // don't end up re-allocating this address on future Terraform runs.
 * const newip = new phpipam.Address("newip", {
 *     subnetId: subnet.then(subnet => subnet.subnetId),
 *     ipAddress: nextAddress.then(nextAddress => nextAddress.ipAddress),
 *     hostname: "tf-test-host.example.internal",
 *     description: "Managed by Terraform",
 * });
 * ```
 * <!--End PulumiCodeChooser -->
 *
 * **Example how to get gateway IP address by subnet_id:**
 *
 * <!--Start PulumiCodeChooser -->
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as phpipam from "@pulumi/phpipam";
 *
 * const section = phpipam.getSection({
 *     name: "Subnet Section",
 * });
 * const subnet = section.then(section => phpipam.getSubnet({
 *     sectionId: section.id,
 *     descriptionMatch: "prod_mgmt",
 * }));
 * const gateway = subnet.then(subnet => phpipam.getAddress({
 *     addressId: subnet.gatewayId,
 * }));
 * ```
 * <!--End PulumiCodeChooser -->
 */
export function getSubnet(args?: GetSubnetArgs, opts?: pulumi.InvokeOptions): Promise<GetSubnetResult> {
    args = args || {};

    opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts || {});
    return pulumi.runtime.invoke("phpipam:index/getSubnet:getSubnet", {
        "customFieldFilter": args.customFieldFilter,
        "description": args.description,
        "descriptionMatch": args.descriptionMatch,
        "sectionId": args.sectionId,
        "subnetAddress": args.subnetAddress,
        "subnetId": args.subnetId,
        "subnetMask": args.subnetMask,
    }, opts);
}

/**
 * A collection of arguments for invoking getSubnet.
 */
export interface GetSubnetArgs {
    /**
     * A map of custom fields to search for. The filter
     * values are regular expressions that follow the RE2 syntax for which you can
     * find documentation [here](https://github.com/google/re2/wiki/Syntax). All
     * fields need to match for the match to succeed.
     *
     * ⚠️  **NOTE:** Searches with the `description`, `descriptionMatch` and
     * `customFieldFilter` fields return the first match found without any warnings.
     * Conversely, the resource fails if it somehow finds multiple results on a CIDR
     * (subnet and mask) search - this is to assert that you are getting the subnet you
     * requested. If you want to return multiple results, combine this data source with
     * the `phpipam.getSubnets` data source. Custom fileds must contain
     * mandatory prefix `custom_`.
     *
     * ⚠️  **NOTE:** An empty or unspecified `customFieldFilter` value is the
     * equivalent to a regular expression that matches everything, and hence will
     * return the first subnetit sees in the section.
     *
     * Arguments are processed in the following order of precedence:
     */
    customFieldFilter?: {[key: string]: any};
    /**
     * The subnet's description. `sectionId` is required if you
     * want to use this option.
     */
    description?: string;
    /**
     * A regular expression to match against when searching
     * for a subnet. `sectionId` is required if you want to use this option.
     */
    descriptionMatch?: string;
    /**
     * , and either one of `description`, `descriptionMatch`, or
     * `customFieldFilter`
     */
    sectionId?: number;
    /**
     * and `subnetMask`
     */
    subnetAddress?: string;
    subnetId?: number;
    /**
     * The subnet mask, in bits, of the subnet to look up.
     */
    subnetMask?: number;
}

/**
 * A collection of values returned by getSubnet.
 */
export interface GetSubnetResult {
    /**
     * `true` if the subnet allows IP requests in PHPIPAM.
     */
    readonly allowIpRequests: boolean;
    /**
     * `true` if PTR records are created for addresses in
     * this subnet.
     */
    readonly createPtrRecords: boolean;
    readonly customFieldFilter?: {[key: string]: any};
    /**
     * A key/value map of custom fields for this subnet.
     */
    readonly customFields: {[key: string]: any};
    /**
     * The description set for the subnet.
     */
    readonly description: string;
    readonly descriptionMatch?: string;
    /**
     * `true` if hostnames are displayed instead of IP
     * addresses in the address listing for this subnet.
     */
    readonly displayHostnames: boolean;
    /**
     * The date this resource was last updated.
     */
    readonly editDate: string;
    /**
     * Key map of values: ip_addr, id. ipAddr - this is gateway IP address
     * (like 192.168.1.254). id - gateway ip ID
     */
    readonly gateway: {[key: string]: any};
    /**
     * The ID of gateway IP address fot this subnet
     */
    readonly gatewayId: string;
    /**
     * `true` if this subnet is included in new host
     * scans.
     */
    readonly hostDiscoveryEnabled: boolean;
    /**
     * The provider-assigned unique ID for this managed resource.
     */
    readonly id: string;
    /**
     * `true` if this subnet is included in ping probes.
     */
    readonly includeInPing: boolean;
    /**
     * `true` if this subnet is a folder and not an actual subnet.
     */
    readonly isFolder: boolean;
    /**
     * `true` if the subnet has been marked as full.
     */
    readonly isFull: boolean;
    /**
     * The ID of the linked subnet in the PHPIPAM database.
     */
    readonly linkedSubnetId: number;
    /**
     * The ID of the location for this subnet.
     */
    readonly locationId: number;
    /**
     * The ID of the parent subnet for this subnet in the
     * PHPIPAM database.
     */
    readonly masterSubnetId: number;
    /**
     * The ID of the nameserver used to assign PTR records for
     * this subnet.
     */
    readonly nameserverId: number;
    readonly nameservers: {[key: string]: any};
    readonly parentSubnetId: number;
    /**
     * A JSON representation of the permissions associated with this
     * subnet.
     */
    readonly permissions: string;
    /**
     * `true` if enabled resolving of DNS names.
     */
    readonly resolveDns: boolean;
    /**
     * The ID of the ping scan agent that is used for this subnet.
     */
    readonly scanAgentId: number;
    /**
     * The ID of the section for this address in the PHPIPAM
     * database.
     */
    readonly sectionId: number;
    /**
     * `true` if the subnet name is are shown in the section, instead
     * of the network address.
     */
    readonly showName: boolean;
    /**
     * The network address of the subnet.
     */
    readonly subnetAddress: string;
    /**
     * The ID of the subnet in the PHPIPAM database.
     */
    readonly subnetId: number;
    /**
     * The subnet mask, in bits.
     */
    readonly subnetMask: number;
    /**
     * The subnet's utilization threshold.
     */
    readonly utilizationThreshold: number;
    /**
     * The ID of the VLAN for this subnet in the PHPIPAM database.
     */
    readonly vlanId: number;
    /**
     * The ID of the VRF for this subnet in the PHPIPAM database.
     */
    readonly vrfId: number;
}
/**
 * ## # phpipam.Subnet
 *
 * The `phpipam.Subnet` data source gets information on a subnet such as its ID
 * (required for creating addresses), description, and more.
 *
 * **Example:**
 *
 * <!--Start PulumiCodeChooser -->
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as phpipam from "@pulumi/phpipam";
 *
 * const subnet = phpipam.getSubnet({
 *     subnetAddress: "10.10.2.0",
 *     subnetMask: 24,
 * });
 * // Reserve the address.
 * const newip = new phpipam.Address("newip", {
 *     subnetId: subnet.then(subnet => subnet.subnetId),
 *     ipAddress: "10.10.2.10",
 *     hostname: "tf-test-host.example.internal",
 *     description: "Managed by Terraform",
 * });
 * ```
 * <!--End PulumiCodeChooser -->
 *
 * **Example with `descriptionMatch`:**
 *
 * <!--Start PulumiCodeChooser -->
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as phpipam from "@pulumi/phpipam";
 *
 * const subnet = phpipam.getSubnet({
 *     sectionId: 1,
 *     descriptionMatch: "[Cc]ustomer 2",
 * });
 * const nextAddress = subnet.then(subnet => phpipam.getFirstFreeAddress({
 *     subnetId: subnet.subnetId,
 * }));
 * // Reserve the address. Note that we use ignore_changes here to ensure that we
 * // don't end up re-allocating this address on future Terraform runs.
 * const newip = new phpipam.Address("newip", {
 *     subnetId: subnet.then(subnet => subnet.subnetId),
 *     ipAddress: nextAddress.then(nextAddress => nextAddress.ipAddress),
 *     hostname: "tf-test-host.example.internal",
 *     description: "Managed by Terraform",
 * });
 * ```
 * <!--End PulumiCodeChooser -->
 *
 * **Example With `customFieldFilter`:**
 *
 * <!--Start PulumiCodeChooser -->
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as phpipam from "@pulumi/phpipam";
 *
 * const subnet = phpipam.getSubnet({
 *     sectionId: 1,
 *     customFieldFilter: {
 *         custom_CustomTestSubnets: ".*terraform.*",
 *     },
 * });
 * const nextAddress = subnet.then(subnet => phpipam.getFirstFreeAddress({
 *     subnetId: subnet.subnetId,
 * }));
 * // Reserve the address. Note that we use ignore_changes here to ensure that we
 * // don't end up re-allocating this address on future Terraform runs.
 * const newip = new phpipam.Address("newip", {
 *     subnetId: subnet.then(subnet => subnet.subnetId),
 *     ipAddress: nextAddress.then(nextAddress => nextAddress.ipAddress),
 *     hostname: "tf-test-host.example.internal",
 *     description: "Managed by Terraform",
 * });
 * ```
 * <!--End PulumiCodeChooser -->
 *
 * **Example how to get gateway IP address by subnet_id:**
 *
 * <!--Start PulumiCodeChooser -->
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as phpipam from "@pulumi/phpipam";
 *
 * const section = phpipam.getSection({
 *     name: "Subnet Section",
 * });
 * const subnet = section.then(section => phpipam.getSubnet({
 *     sectionId: section.id,
 *     descriptionMatch: "prod_mgmt",
 * }));
 * const gateway = subnet.then(subnet => phpipam.getAddress({
 *     addressId: subnet.gatewayId,
 * }));
 * ```
 * <!--End PulumiCodeChooser -->
 */
export function getSubnetOutput(args?: GetSubnetOutputArgs, opts?: pulumi.InvokeOptions): pulumi.Output<GetSubnetResult> {
    return pulumi.output(args).apply((a: any) => getSubnet(a, opts))
}

/**
 * A collection of arguments for invoking getSubnet.
 */
export interface GetSubnetOutputArgs {
    /**
     * A map of custom fields to search for. The filter
     * values are regular expressions that follow the RE2 syntax for which you can
     * find documentation [here](https://github.com/google/re2/wiki/Syntax). All
     * fields need to match for the match to succeed.
     *
     * ⚠️  **NOTE:** Searches with the `description`, `descriptionMatch` and
     * `customFieldFilter` fields return the first match found without any warnings.
     * Conversely, the resource fails if it somehow finds multiple results on a CIDR
     * (subnet and mask) search - this is to assert that you are getting the subnet you
     * requested. If you want to return multiple results, combine this data source with
     * the `phpipam.getSubnets` data source. Custom fileds must contain
     * mandatory prefix `custom_`.
     *
     * ⚠️  **NOTE:** An empty or unspecified `customFieldFilter` value is the
     * equivalent to a regular expression that matches everything, and hence will
     * return the first subnetit sees in the section.
     *
     * Arguments are processed in the following order of precedence:
     */
    customFieldFilter?: pulumi.Input<{[key: string]: any}>;
    /**
     * The subnet's description. `sectionId` is required if you
     * want to use this option.
     */
    description?: pulumi.Input<string>;
    /**
     * A regular expression to match against when searching
     * for a subnet. `sectionId` is required if you want to use this option.
     */
    descriptionMatch?: pulumi.Input<string>;
    /**
     * , and either one of `description`, `descriptionMatch`, or
     * `customFieldFilter`
     */
    sectionId?: pulumi.Input<number>;
    /**
     * and `subnetMask`
     */
    subnetAddress?: pulumi.Input<string>;
    subnetId?: pulumi.Input<number>;
    /**
     * The subnet mask, in bits, of the subnet to look up.
     */
    subnetMask?: pulumi.Input<number>;
}
